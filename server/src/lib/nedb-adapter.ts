import * as dirs from './dirs';
import * as configLoader from '../lib/config-loader';
import * as constants from './constants';
import {
    ActorSessionState,
    DbAdapter,
    QueryOptions,
    SegmentUpdateInfo,
    TestActor,
    TestSessionInfo,
    TestContext
} from './types';
import * as helpers from './helpers';
import * as mkdirp from 'mkdirp';
import * as moment from 'moment';
import * as NeDBDatastore from 'nedb';
import * as path from 'path';
import * as thenify from 'thenify';
import * as util from 'util';

export interface NeDbOptions {
    nedbPath?: string
}

export interface DbQueryOptions {
    limit?: number,
    query?: any,
    skip?: number
}

export class NedbAdapter implements DbAdapter {
    private actorsCol: Nedb;
    private sessionsCol: Nedb;
    private testsCol: Nedb;
    private options: NeDbOptions;
    private usersCol: Nedb;

    constructor(options?: NeDbOptions) {
        this.options = options || {};
        this.options.nedbPath = this.options.nedbPath || path.join(dirs.workingDir(), 'db');
    }

    async findOne<Type>(collection, query) : Promise<Type>{
        return new Promise(function(resolve, reject) {
            collection.findOne(query, function (err, result : Type) {
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });            
        });
    }


    async find<Type>(collection, query) : Promise<Type[]>{
        return new Promise(function(resolve, reject) {
            collection.find(query, function (err, result : Type[]) {
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });    
        });
    }

    async insert(collection, newItem) : Promise<void>{
        return new Promise(function(resolve, reject) {
            collection.insert(newItem, function (err, result) {
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });    
        });
    }

    async update(collection, query, updateQuery, options) : Promise<number>{
        return new Promise(function(resolve, reject) {
            collection.update(query, updateQuery, options, function (err, result : number) {
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });    
        });
    }
    
    async remove(collection, query, options) : Promise<number>{
        return new Promise(function(resolve, reject) {
            collection.remove(query, options, function (err, result : number) {
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });    
        });
    }
    
    
    closeDb() {
        this.sessionsCol.persistence.stopAutocompaction();
        this.testsCol.persistence.stopAutocompaction();
    }

    async deleteActor(actorId: number): Promise<number> {
        return this.remove(this.actorsCol, { id: actorId }, {});
    }

    async deleteTests(sessionId: number): Promise<number> {
        return this.remove(this.testsCol, { sessionId: sessionId }, {});
    }
    
    async deleteSession(sessionId: number): Promise<number> {
        await this.deleteTests(sessionId);
        return this.remove(this.sessionsCol, { id: sessionId }, {});
    }

    async deleteArchivedSession(sessionId: number): Promise<number> {
        return this.deleteSession(sessionId);
    }

    async getActor(actorId): Promise<TestActor> {
        return this.findOne<TestActor>(this.actorsCol, { id: actorId });
    }

    async getActorsBySession(sessionId): Promise<TestActor[]> {
        let query = sessionId ? { testSessionId: sessionId } : {};
        return this.find<TestActor>(this.actorsCol, query);
    }

    async getActorsByTypeAndTags(actorType?: string, actorTags?: string[]): Promise<TestActor[]> {
        let self = this;

        let query: any = {};

        if (actorType) {
            query.type = actorType
        }

        let requestedTags = actorTags || [];

        // Trim tags and remove empty ones
        requestedTags = requestedTags
            .map(tag => tag.trim())
            .filter(tag => tag.length > 0);

        var actors = await this.find<TestActor>(this.actorsCol, query);
        
        const actorsWithTags = actors.filter(function (actor) {
            const actorTagRegex = /^((.+?)\s*:\s*)?([\w\-+\[\].\/]+)$/;
            let hasAllTags = true;
            for (let requestedTag of requestedTags) {
                const tagMatch = actorTagRegex.exec(requestedTag);
                if (tagMatch) {
                    const actorType = tagMatch[2];
                    const tag = tagMatch[3];

                    const actorTypeMatches = !actorType || (actor.type.toLowerCase() === actorType.toLowerCase());
                    const tagExists = actor.tags.indexOf(tag) >= 0;

                    if (actorTypeMatches && !tagExists) {
                        hasAllTags = false;
                        break;
                    }
                }
            }
            return hasAllTags;
        });
        
        return actorsWithTags;
    }

    async getTests(sessionId: number): Promise<TestContext[]> {
        var tests = await this.find<TestContext>(this.testsCol, {sessionId: sessionId});
        
        tests.sort(function (a : TestContext, b : TestContext) {
            return a.testIndex < b.testIndex ? -1 : (a.testIndex == b.testIndex ? 0 : 1);
        });
        
        return tests;
    }

    async getTest(sessionId: number, testIndex: number): Promise<TestContext> {
        return this.findOne<TestContext>(this.testsCol, {sessionId: sessionId, testIndex: testIndex});        
    }

    async getSession(sessionId: number): Promise<TestSessionInfo> {
        var session = await this.findOne<TestSessionInfo>(this.sessionsCol, { id: sessionId });
        
        if (session) {
            var testData = await this.getTests(sessionId);
            var testDataArray = [];
            
            for (var testIndex = 0; testIndex < testData.length; testIndex += 1) {
                testDataArray[testData[testIndex].testIndex] = testData[testIndex];
            }
            
            for (var testIndex = 0; testIndex < session.tests.length; testIndex += 1) {
                if (testDataArray[testIndex]) {
                    session.tests[testIndex].actions = testDataArray[testIndex].actions;
                    session.tests[testIndex].subtests = testDataArray[testIndex].subtests;
                }
            }
        }
        
        return session;
    }

    async getSessionLight(sessionId: number): Promise<TestSessionInfo> {
        var session = await this.findOne<TestSessionInfo>(this.sessionsCol, { id: sessionId });
                
        return session;
    }

    async getArchivedSession(sessionId: number): Promise<TestSessionInfo> {
        return this.getSession(sessionId);
    }
    
    async getArchivedSessions(): Promise<TestSessionInfo[]> { return null; }

    async getSessions(options: QueryOptions = {}): Promise<TestSessionInfo[]> {
        var sessions = await this.find<TestSessionInfo>(this.sessionsCol, {});
        
        sessions.sort(function (a : TestSessionInfo, b : TestSessionInfo) {
            return a.timeCreated > b.timeCreated ? -1 : (
                a.timeCreated == b.timeCreated ? 0 : 1
            )
        });

        var result : TestSessionInfo[] = [];
        var skip = options.skip || 0;
        var limit = options.limit || sessions.length;
        limit += skip;
        
        for (var sessionIndex = skip; sessionIndex < limit && sessionIndex < sessions.length; sessionIndex += 1) {
            var session = sessions[sessionIndex];
            
            session.tests = await this.getTests(session.id);
            result.push(session);
        }

        return result;
    }

    initDb() {
        const config = configLoader.getConfig();
        const dbCompactionIntervalMs = Math.min(config.dbCompactionIntervalSec * 1000, 10 * 60 * 1000);

        mkdirp.sync(this.options.nedbPath);

        this.actorsCol = new NeDBDatastore({ filename: path.join(this.options.nedbPath, 'actors'), autoload: true });
        this.sessionsCol = new NeDBDatastore({ filename: path.join(this.options.nedbPath, 'sessions'), autoload: true });
        this.sessionsCol.persistence.setAutocompactionInterval(dbCompactionIntervalMs);
        this.testsCol = new NeDBDatastore({ filename: path.join(this.options.nedbPath, 'tests'), autoload: true });
        this.testsCol.persistence.setAutocompactionInterval(dbCompactionIntervalMs);
        this.usersCol = new NeDBDatastore({ filename: path.join(this.options.nedbPath, 'users'), autoload: true });
    }

    async insertActor(actorId: number, actorType: string): Promise<TestActor> {
        var self = this;

        var countPromise = new Promise<number>((resolve, reject) => {
            self.actorsCol.count({ id: actorId }, function (err, recordCount) {
                if (err) {
                    reject(err);
                } else {
                    resolve(recordCount);
                }
            });
        });

        return countPromise.then(function (recordCount): Promise<TestActor> {
            if (recordCount > 0) {
                return Promise.reject(new Error(util.format(
                    'Actor ID %s already exists',
                    actorId)));
            } else {
                return new Promise<TestActor>(function (resolve, reject) {
                    let newActor: TestActor = {
                        id: actorId,
                        lastSeenTime: Date.now(),
                        testSessionId: null,
                        type: actorType,
                        tags: []
                    };

                    self.actorsCol.insert(newActor, function (err, actor) {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(actor);
                        }
                    });
                });
            }
        });
    }

    async insertSession(sessionId: number, label: string): Promise<TestSessionInfo> {
        var self = this;
        let now = Date.now();

        var countPromise = new Promise<number>((resolve, reject) => {
            self.sessionsCol.count({ id: sessionId }, function (err, recordCount) {
                if (err) {
                    reject(err);
                } else {
                    resolve(recordCount);
                }
            });
        });

        return countPromise.then(function (recordCount): Promise<TestSessionInfo> {
            if (recordCount > 0) {
                return Promise.reject(new Error(util.format(
                    'Session ID %s already exists',
                    sessionId)));
            } else {
                return new Promise<TestSessionInfo>(function (resolve, reject) {
                    let newSession: TestSessionInfo = {
                        id: sessionId,
                        actors: {},
                        maxIterations: 1,
                        currentIteration: 1,
                        currentTestIndex: 0,
                        currentSegmentIndex: 0,
                        label: label,
                        result: constants.testSessionResult.PENDING,
                        status: constants.testSessionStatus.ACQUIRING_ACTORS,
                        tests: [],
                        timeCreated: Date.now(),
                        timeStarted: null,
                        timeCompleted: null,
                        lastActivity: now
                    };

                    self.sessionsCol.insert(newSession, function (err, actor) {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(actor);
                        }
                    });
                });
            }
        });
    }

    async insertArchivedSession(sessionId: number, label: string): Promise<TestSessionInfo> {
        let self = this;
        return self.insertSession(sessionId, label);
    }
    
    async resetDb() {
        let self = this;

        await self.actorsCol.remove({}, { multi: true });
        await self.actorsCol.persistence.compactDatafile();
        await self.sessionsCol.remove({}, { multi: true });
        await self.sessionsCol.persistence.compactDatafile();
        await self.testsCol.remove({}, { multi: true });
        await self.testsCol.persistence.compactDatafile();
        await self.usersCol.remove({}, { multi: true });
        await self.usersCol.persistence.compactDatafile();
    }

    async updateActorSegment(
        sessionId: number,
        actorId: number,
        testIndex: number,
        segmentIndex: number,
        newData: SegmentUpdateInfo) {
        
        const self = this;
        const now = Date.now();
        const sessionHelper = require('../lib/session-helper');

        var testSession = await this.getSessionLight(sessionId);

        if (!testSession) {
            throw new Error(util.format('Session ID %s was not found', sessionId));
        }

        testSession.lastActivity = now;

        const sessionActor: ActorSessionState = testSession.actors[actorId];
        // Print update requests at the console for troubleshooting purposes
        // console.log(`${sessionActor.type}, TS${testIndex}, SEG${segmentIndex}, ${JSON.stringify(newData)}`);

        if (!sessionActor) {
            throw new Error(util.format('Session actor with ID %s was not found for session %s', actorId, sessionId));
        }

        // Make sure testIndex is integer
        let testIndexInt = parseInt(testIndex as any);
        if (!Number.isInteger(testIndexInt)) {
            throw new Error(helpers.format(
                "Method updateActorSegment was called with an invalid testIndex parameter. The value received was {0}",
                testIndex));
        }
        testIndex = testIndexInt;

        var persistedTestData = await self.getTest(sessionId, testIndex);
        
        if (persistedTestData) {
            testSession.tests[testIndex].actions = persistedTestData.actions;
            testSession.tests[testIndex].subtests = persistedTestData.subtests;
        }
         
        if (newData.actions) {
            if (Array.isArray(newData.actions)) {
                for (let action of newData.actions) {
                    if (action.duration && !action.durationMs) {
                        action.durationMs = action.duration * 1000;
                    }

                    // Remove this block once support for the "step"
                    // terminology is completely abandoned
                    if (action.step) {
                        if (!action.segment) {
                            action.segment = action.step;
                        }
                        delete action.step;
                    }

                    action.args = helpers.escape$Properties(action.args);
                }
            }               
            
            testSession.tests[testIndex].actions = testSession.tests[testIndex].actions.concat(newData.actions);
        }

        // In segment 0 of data-driven tests, actors report the total number of
        // data records available. We store that number in the test context so
        // we know how many iterations to process.
        if (newData.dataRecordCount) {
            if (!Number.isInteger(newData.dataRecordCount)) {
                throw new Error(helpers.format(
                    "The dataRecordCount field must be an integer. The value received was {0}.",
                    newData.dataRecordCount));
            }

            // The dataRecordCount field will only be sent by actors in segment 0 of data-driven tests
            if (testSession.tests[testIndex].currentSegmentIndex == 0) {
                testSession.tests[testIndex].dataRecordCount = newData.dataRecordCount;
                testSession.tests[testIndex].currentSegmentIndex = 1;
            }
        }

        if (newData.stackTrace) {
            testSession.actors[actorId].tests[testIndex].segments[segmentIndex].stackTrace = newData.stackTrace;
        }

        if (newData.status) {
            sessionHelper.updateActorSegmentStatus(testSession, actorId, testIndex, segmentIndex, newData.status);
        }

        if (newData.result) {
            testSession.actors[actorId].tests[testIndex].segments[segmentIndex].result = newData.result;
        }

        sessionHelper.updateSessionState(testSession);
        
        var testData = testSession.tests[testIndex];
        
        await self.testsCol.update({sessionId: testData.sessionId, testIndex: testData.testIndex}, { $set: {
            "sessionId": sessionId,
            "testIndex": testIndex,
            "actions": testData.actions,
            "subtests": testData.subtests
        }}, {upsert: true});

        delete testData.actions;

        var subtests = [];
        for (var subtestIndex in testData.subtests) {
            var subtest = testData.subtests[subtestIndex];
            subtests[subtestIndex] = {
                status: subtest.status,
                result: subtest.result,
                currentIteration: subtest.currentIteration
            };
        };
        
        testData.subtests = subtests;
        
        await self.updateSession(sessionId, testSession);
    }

    async updateActor(actorId, newData): Promise<number> {
        let self = this;

        actorId = parseInt(actorId);

        return new Promise<number>(function (resolve, reject) {
            self.actorsCol.update({ id: actorId }, { $set: newData }, {}, function (err, numUpdated) {
                if (err) {
                    reject(err);
                } else {
                    resolve(numUpdated);
                }
            });
        });
    }

    async updateTests(sessionId: number, tests: TestContext[]) : Promise<void>
    {
        let self = this;

        var updateTestPromises : Array<Promise<void>> = [];

        // Possible bug: this only inserts or updates, but does not remove tests
        // However, I cannot think of a scenario when this can happen
        for (var testIndex = 0; testIndex < tests.length; testIndex += 1) {
            var updateTestPromise = new Promise<void>(function (resolve, reject) {
                var test = {
                    "sessionId": sessionId,
                    "testIndex": testIndex,
                    "actions": tests[testIndex].actions,
                    "subtests": tests[testIndex].subtests
                };
                
                self.testsCol.update({sessionId: sessionId, testIndex: testIndex}, test, {upsert: true}, function(err, numUpdated) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve();
                    }
                });
            });
            
            updateTestPromises.push(updateTestPromise);
        }
        
        await Promise.all(updateTestPromises);
    }
    
    async updateSession(sessionId: number, newData: Object): Promise<number> {
        return this.update(this.sessionsCol, { id: sessionId }, { $set: newData }, {});
    }
    
    async updateArchivedSession(sessionId: number, newData: Object): Promise<number> {
        return this.updateSession(sessionId, newData);
    }
}